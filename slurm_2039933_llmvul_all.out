[SLURM] Job ID     : 2039933
[SLURM] Submit dir : /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul
[SLURM] Output file: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/slurm_2039933_llmvul_all.out
[ENV] Using ct-env: /home/chun7871/.conda/envs/ct-env/bin/python
 LLMvul – Full Run
 Repo   : /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul
 Output : /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out
 Started: Sun Feb 22 05:39:30 PM CET 2026

──────────────────────────────────────────────────────────
 Step 1: Main Pipeline (prime.py)
 Script : prime.py
 Started: Sun Feb 22 05:39:30 PM CET 2026
──────────────────────────────────────────────────────────
[INFO] Loading tokenizer...
[INFO] Tokenizer loaded.
[INFO] Loading ReplacementModel...
Fetching 26 files:   0%|          | 0/26 [00:00<?, ?it/s]Fetching 26 files:   4%|3         | 1/26 [00:00<00:09,  2.62it/s]Fetching 26 files:  35%|###4      | 9/26 [00:00<00:00, 22.61it/s]Fetching 26 files:  65%|######5   | 17/26 [00:00<00:00, 36.18it/s]Fetching 26 files:  88%|########8 | 23/26 [00:00<00:00, 42.05it/s]Fetching 26 files: 100%|##########| 26/26 [00:00<00:00, 34.52it/s]
Loading checkpoint shards:   0%|          | 0/3 [00:00<?, ?it/s]Loading checkpoint shards:  33%|###3      | 1/3 [00:08<00:16,  8.17s/it]Loading checkpoint shards:  67%|######6   | 2/3 [00:21<00:11, 11.23s/it]Loading checkpoint shards: 100%|##########| 3/3 [00:22<00:00,  6.61s/it]Loading checkpoint shards: 100%|##########| 3/3 [00:22<00:00,  7.55s/it]
Loaded pretrained model Chun9622/llmvul-finetuned-gemma into HookedTransformer
[INFO] ReplacementModel loaded.
[INFO] Model set to eval mode.
[START] Begin analysis...
[INFO] Processing 236 VUL samples (optimized GPU utilization)
[VUL] Sample 1/236 [len=422]
[VUL] Sample 10/236 [len=512]
→ Sample 1/236 | True: vul | Pred: nonvul | Output: value_size() != 1) {
      return errors::FailedPrecondition(
          strings:...
→ Sample 2/236 | True: vul | Pred: vul | Output: ");
  }
  if (shape.dims() != 2) {
    return errors::Internal("Node ", node.nam...
→ Sample 3/236 | True: vul | Pred: nonvul | Output: Code: u32 GetHintFormat(GF_TrackBox *trak)
{
	GF_HintMediaHeaderBox *hmhd = (GF_...
→ Sample 4/236 | True: vul | Pred: nonvul | Output: if (total_inputs_size == 0) {
    return Status(error::INVALID_ARGUMENT,
       ...
→ Sample 5/236 | True: vul | Pred: nonvul | Output: ::InvalidArgument(
            "SparseTensorsMap requires rank > 1, but got rank...
→ Sample 6/236 | True: vul | Pred: vul | Output: }
    } else {
      input_types.emplace_back(no_type);
    }
  }

  // TODO(b/1...
[VUL] Sample 20/236 [len=275]
→ Sample 7/236 | True: vul | Pred: nonvul | Output: OP_REQUIRES(context, input_indices->NumElements() == new_num_elements,
         ...
→ Sample 8/236 | True: vul | Pred: nonvul | Output: 0);
  }
  else {
    mrb_value *ptr = ARY_PTR(a);
    mrb_int size = len-n;

   ...
→ Sample 9/236 | True: vul | Pred: nonvul | Output: auto& consumer : node_map_->GetOutputs(node.name())) {
    if (node.input_size()...
→ Sample 10/236 | True: vul | Pred: nonvul | Output: )
				ctx->dts = ts;
		}
	}

	//check if we have a valid duration
	if (ctx->dura...
→ Sample 11/236 | True: vul | Pred: nonvul | Output: ; i++)
		c->intercepts[i] |= g->intercepts[i];

	/* If SMI is not intercepted, i...
→ Sample 12/236 | True: vul | Pred: nonvul | Output: shape;
  set_dtype(proto.dtype());
  UnrefIfNonNull(buf_);
  buf_ = p;
  // TODO...
→ Sample 13/236 | True: vul | Pred: vul | Output: error();
    if (!SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL)) {
#ifdef NETDE...
→ Sample 14/236 | True: vul | Pred: nonvul | Output: Failed to create work directory");

	if (tmate_settings->bind_addr) {
		if (bind...
→ Sample 15/236 | True: vul | Pred: nonvul | Output: Code: Status SetUnknownShape(const NodeDef* node, int output_port) {
    shape_i...
→ Sample 16/236 | True: vul | Pred: nonvul | Output: >(
                                &op_reg_data->op_def, std::move(node_def),
  ...
[VUL] Sample 30/236 [len=512]
→ Sample 17/236 | True: vul | Pred: nonvul | Output: : It is safe.
→ Sample 18/236 | True: vul | Pred: nonvul | Output: input("key", &key_tensor));
    OP_REQUIRES_OK(ctx, ctx->input("indices", &indic...
→ Sample 19/236 | True: vul | Pred: nonvul | Output: DT_INT64) {
    concat_dim = concat_dim_t->scalar<int64>()();
  } else {
    ret...
→ Sample 20/236 | True: vul | Pred: nonvul | Output: int64_t total_output_size = 0;
  // Use float as default for calculations.
  for...
→ Sample 21/236 | True: vul | Pred: nonvul | Output: Def>& a1,
    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {
  std::uno...
→ Sample 22/236 | True: vul | Pred: nonvul | Output: Code: bool IsIdentityConsumingSwitch(const MutableGraphView& graph,
            ...
→ Sample 23/236 | True: vul | Pred: nonvul | Output: Code: int TfLiteIntArrayGetSizeInBytes(int size) {
  static TfLiteIntArray dummy...
→ Sample 24/236 | True: vul | Pred: nonvul | Output: Code: TfLiteIntArray* TfLiteIntArrayCreate(int size) {
  int alloc_size = TfLite...
→ Sample 25/236 | True: vul | Pred: nonvul | Output: =DefaultResolution;
  if (image_info->density != (const char *) NULL)
    {
    ...
→ Sample 26/236 | True: vul | Pred: nonvul | Output: Code: void gitn_box_del(GF_Box *s)
{
	u32 i;
	GroupIdToNameBox *ptr = (GroupIdTo...
[VUL] Sample 40/236 [len=117]
→ Sample 27/236 | True: vul | Pred: nonvul | Output: i = 0; i < num_indices; ++i) {
      int64_t batch_index = indices->flat<int64_t...
→ Sample 28/236 | True: vul | Pred: vul | Output: Code: static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
...
→ Sample 29/236 | True: vul | Pred: nonvul | Output: Is this code safe or vulnerable?
Answer: It is safe.
→ Sample 30/236 | True: vul | Pred: nonvul | Output: until_ch(scanner, '>', &end_name);
    pj_scan_advance_n(scanner, 1, PJ_FALSE);
...
→ Sample 31/236 | True: vul | Pred: nonvul | Output: current_top_box_start + mov->bytes_removed) > mov->movieFileMap->bs->size) {
			...
→ Sample 32/236 | True: vul | Pred: nonvul | Output: _t));
    float epsilon = epsilon_t->scalar<float>()();
    OP_REQUIRES(
       ...
→ Sample 33/236 | True: vul | Pred: vul | Output: class */
    pj_memcpy(&q->dnsclass, p, 2);
    q->dnsclass = pj_ntohs(q->dnscla...
→ Sample 34/236 | True: vul | Pred: nonvul | Output: Code: GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)
{
	u32 i;
	char str[1024...
→ Sample 35/236 | True: vul | Pred: nonvul | Output: , ssm.type(), fname,
                                    ss_slice, &tensors_);
 ...
→ Sample 36/236 | True: vul | Pred: nonvul | Output: It is safe.
[VUL] Sample 50/236 [len=451]
→ Sample 37/236 | True: vul | Pred: vul | Output: Code: int digest_generic_verify(struct digest *d, const unsigned char *md)
{
	in...
→ Sample 38/236 | True: vul | Pred: nonvul | Output: if (exclude_trailing_space)
    {
	int s = bd->textlen + bd->endspaces;

	while ...
→ Sample 39/236 | True: vul | Pred: nonvul | Output: file, sizeof(cl.lockfile)-1,
				"%s/%s.pid", BOOTH_RUN_DIR, booth_conf->name);
...
→ Sample 40/236 | True: vul | Pred: nonvul | Output: Code: mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)
{
  mt_tb...
→ Sample 41/236 | True: vul | Pred: nonvul | Output: Code: void Compute(OpKernelContext* ctx) override {
    Buffer* buf = nullptr;
 ...
→ Sample 42/236 | True: vul | Pred: nonvul | Output: _flat = a_shape->flat<Index>();
  for (int i = 0; i < b->dims(); ++i) {
    if (...
→ Sample 43/236 | True: vul | Pred: nonvul | Output: ()) {
    return errors::InvalidArgument(
        "Example weights must be less ...
→ Sample 44/236 | True: vul | Pred: nonvul | Output: js_object_prop_t  *prop;

    njs_set_array(&value, array);
    array->object.fa...
→ Sample 45/236 | True: vul | Pred: nonvul | Output: = ctx->input(0);
    int64 id = ctx->session_state()->GetNewId();
    TensorStor...
→ Sample 46/236 | True: vul | Pred: nonvul | Output: Code: Status SparseCountSparseOutputShapeFn(InferenceContext *c) {
  auto rank =...
[VUL] Sample 60/236 [len=385]
→ Sample 47/236 | True: vul | Pred: vul | Output: } else {
      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU...
→ Sample 48/236 | True: vul | Pred: nonvul | Output: } else if (output->type == kTfLiteUInt8) {
    TF_LITE_ENSURE_OK(
        contex...
→ Sample 49/236 | True: vul | Pred: vul | Output: {
	    if (pkttype && pkt.tag != pkttype) {
		break;
	    } else {
		digp = pgpD...
→ Sample 50/236 | True: vul | Pred: nonvul | Output: sizeof(std::remove_reference<decltype(hash)>::type::value_type));
    RELEASE_AS...
[VUL] Progress: 50/236 completed, 50 with L0 data (100.0% success)
→ Sample 51/236 | True: vul | Pred: nonvul | Output: y = modn.Multiply(y, rInv);				// unblind
	y = STDMIN(y, m_n-y);
	if (ApplyFunct...
→ Sample 52/236 | True: vul | Pred: nonvul | Output: Code: void Compute(OpKernelContext* ctx) override {
    const Tensor& in0 = ctx-...
→ Sample 53/236 | True: vul | Pred: nonvul | Output: return -1;
    filesystem::path fsPath(utils::toNativePath(path));
    if (!fsPa...
→ Sample 54/236 | True: vul | Pred: nonvul | Output: (*err) += ss.str();
      }
      return TINYEXR_ERROR_INVALID_DATA;
    }
  }

...
→ Sample 55/236 | True: vul | Pred: vul | Output: info->file.start = (u_char *) &info->path[0];
    info->file.length = njs_strlen...
→ Sample 56/236 | True: vul | Pred: nonvul | Output: index) {
      return errors::Internal(
          "Function instantiation includ...
[VUL] Sample 70/236 [len=512]
→ Sample 57/236 | True: vul | Pred: nonvul | Output: = (pj_uint8_t*)hdr + sizeof(*hdr);
    padlen = *p++;
    rpsi->pt = (*p++ & 0x7...
→ Sample 58/236 | True: vul | Pred: nonvul | Output: Code: void Compute(OpKernelContext* ctx) override {
    const Tensor& handle = c...
→ Sample 59/236 | True: vul | Pred: nonvul | Output: HANDLE_REVERSE(5);
        HANDLE_REVERSE(6);
        HANDLE_REVERSE(7);
       ...
→ Sample 60/236 | True: vul | Pred: nonvul | Output: > 1) {
        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,s...
→ Sample 61/236 | True: vul | Pred: nonvul | Output: set_undefined(p);
        }

        *local++ = p++;
    }

    return NJS_OK;
}...
→ Sample 62/236 | True: vul | Pred: nonvul | Output: in checkpoint file");
  }
  std::swap(*out_tensor, t);

  return Status::OK();
}...
→ Sample 63/236 | True: vul | Pred: nonvul | Output: 8_t, IndicesT>(params, indices, output);
    case kTfLiteInt16:
      return Gat...
→ Sample 64/236 | True: vul | Pred: nonvul | Output: Answer: It is safe.
→ Sample 65/236 | True: vul | Pred: nonvul | Output: command_field_new(com);
	inf->new_node = node;
	inf->field_ptr = &inf->new_node;...
→ Sample 66/236 | True: vul | Pred: nonvul | Output: Code: TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* ...
[VUL] Sample 80/236 [len=512]
→ Sample 67/236 | True: vul | Pred: nonvul | Output: _segment_id(i) >= 0)),
          errors::InvalidArgument("Invalid segment_id ", ...
→ Sample 68/236 | True: vul | Pred: nonvul | Output: Tensor y = x;  // This creates an alias intentionally.
    // Skip processing if...
→ Sample 69/236 | True: vul | Pred: nonvul | Output: OP_REQUIRES(context, TensorShapeUtils::IsScalar(iou_threshold.shape()),
        ...
→ Sample 70/236 | True: vul | Pred: nonvul | Output: col_to_new_col_map;
    std::vector<bool> col_id_present;
    const Tensor* col_...
→ Sample 71/236 | True: vul | Pred: nonvul | Output: MATLAB_HDR.Version) != 2)
    ThrowReaderException(CorruptImageError,"ImproperIm...
→ Sample 72/236 | True: vul | Pred: nonvul | Output: Code: TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* n...
→ Sample 73/236 | True: vul | Pred: nonvul | Output: TF_LITE_ENSURE_OK(context,
                          GetInputSafe(context, node,...
→ Sample 74/236 | True: vul | Pred: nonvul | Output: _values, context));
  }

Question: Is this code safe or vulnerable?
Answer: It i...
→ Sample 75/236 | True: vul | Pred: nonvul | Output: OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,
                error...
→ Sample 76/236 | True: vul | Pred: vul | Output: "Invalid address '%s' given to PORT command", addr);
		send_msg(ctrl->sd, "500 I...
[VUL] Sample 90/236 [len=340]
→ Sample 77/236 | True: vul | Pred: nonvul | Output: len) {
	    PJ_LOG(4,(THIS_FILE, "Error: invalid attr length %d (expecting %d)",...
→ Sample 78/236 | True: vul | Pred: nonvul | Output: std::unique_ptr<BoostedTreesEnsembleResource> result(
        new BoostedTreesEn...
→ Sample 79/236 | True: vul | Pred: nonvul | Output: meral = 0;
        if (EVP_PKEY_verify(sec_key, key, key_len) <= 0) {
          ...
→ Sample 80/236 | True: vul | Pred: vul | Output: + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print("Out of ...
→ Sample 81/236 | True: vul | Pred: nonvul | Output: bytes = 0;

	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
	if (!skb)
		return -ENOMEM...
→ Sample 82/236 | True: vul | Pred: nonvul | Output: length);
        return TPM_BAD_PARAMETER;
    }

    if (bh->min_version > BLOB...
→ Sample 83/236 | True: vul | Pred: vul | Output: _silence(format,
						   runtime->oss.period + runtime->oss.period_ptr,
						 ...
→ Sample 84/236 | True: vul | Pred: vul | Output: Code: static void rtrs_clt_dev_release(struct device *dev)
{
	struct rtrs_clt_se...
→ Sample 85/236 | True: vul | Pred: vul | Output: Code: PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )
{
    int chr = *scann...
→ Sample 86/236 | True: vul | Pred: nonvul | Output: file = Ufopen(filename, "rb");
  #endif  /* if neither defined */

  /* If the f...
[VUL] Sample 100/236 [len=204]
→ Sample 87/236 | True: vul | Pred: nonvul | Output: hw_start(hdev, HID_CONNECT_DEFAULT);
	if (ret) {
		hid_err(hdev, "hw start faile...
→ Sample 88/236 | True: vul | Pred: nonvul | Output: ) && (*from == data))
                from += step;
            /* Now (from - s...
→ Sample 89/236 | True: vul | Pred: vul | Output: return_data = talloc(ctx, *out_len);
		if (return_data == NULL) {
			return STAT...
→ Sample 90/236 | True: vul | Pred: nonvul | Output: Sz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		b...
→ Sample 91/236 | True: vul | Pred: nonvul | Output: buf,
				  struct dma_buf_attachment *attachment)
{
	struct fastrpc_dma_buf_atta...
→ Sample 92/236 | True: vul | Pred: nonvul | Output: }

    if (STRNEQ(xml, data->expect)) {
        fprintf(stderr, "\n backing stor...
→ Sample 93/236 | True: vul | Pred: nonvul | Output: if (has_mbyte && *lenp > 0)
	    // Correct the length to include all bytes of t...
→ Sample 94/236 | True: vul | Pred: vul | Output: != orig_pte);
}

Question: Is this code safe or vulnerable?
Answer: It is vulner...
→ Sample 95/236 | True: vul | Pred: vul | Output: Code: static int selinux_ptrace_traceme(struct task_struct *parent)
{
	return av...
→ Sample 96/236 | True: vul | Pred: nonvul | Output: *)"\\[");
	    ga_concat_esc(gap, p, clen);
	    ga_concat(gap, (char_u *)" occu...
[VUL] Sample 110/236 [len=512]
→ Sample 97/236 | True: vul | Pred: nonvul | Output: FS_IOC_GETFLAGS
#else
	    EXT2_IOC_GETFLAGS
#endif
	    , &oldflags) < 0) {
		r...
→ Sample 98/236 | True: vul | Pred: nonvul | Output: attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);
			} else {
...
→ Sample 99/236 | True: vul | Pred: vul | Output: (overflow2(windows_size, sizeof(double))) {
			overflow_error = 1;
		} else {
		...
→ Sample 100/236 | True: vul | Pred: vul | Output: Code: append_command(char_u *cmd)
{
    char_u *s = cmd;
    char_u *d;

    STR...
[VUL] Progress: 100/236 completed, 100 with L0 data (100.0% success)
→ Sample 101/236 | True: vul | Pred: nonvul | Output: return 0;

fail:
    g_free(s->catalog_bitmap);
    return ret;
}

Question: Is ...
→ Sample 102/236 | True: vul | Pred: vul | Output: Code: lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)
{
    gx_dev...
→ Sample 103/236 | True: vul | Pred: nonvul | Output: Code: fname_match(
    regmatch_T	*rmp,
    char_u	*name,
    int		ignore_case) ...
→ Sample 104/236 | True: vul | Pred: nonvul | Output: Yes, it is safe.
→ Sample 105/236 | True: vul | Pred: vul | Output: Code: static Bigint * Balloc(int k)
{
	int x;
	Bigint *rv;

	_THREAD_PRIVATE_MUT...
→ Sample 106/236 | True: vul | Pred: vul | Output: ->value.bytes = ptr + size;
    r_set_size(op1, count + (!forward ? (size - 1) :...
[VUL] Sample 120/236 [len=355]
→ Sample 107/236 | True: vul | Pred: vul | Output: Code: l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
  CallInfo *c...
→ Sample 108/236 | True: vul | Pred: vul | Output: if (!p2) {
		p2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);
		if (!p2)...
→ Sample 109/236 | True: vul | Pred: nonvul | Output: *ax;

	write_lock_irq(&disc_data_lock);
	ax = tty->disc_data;
	tty->disc_data = ...
→ Sample 110/236 | True: vul | Pred: nonvul | Output: } else {
			res = read_directory_data(&dirh, &start, &offset, sizeof(dirh));
			...
→ Sample 111/236 | True: vul | Pred: nonvul | Output: dirh);
		} else {
			res = read_directory_data(&dirh, &start, &offset, sizeof(di...
→ Sample 112/236 | True: vul | Pred: vul | Output: Code: static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff ...
→ Sample 113/236 | True: vul | Pred: vul | Output: }

		*rpc = &self->rpc;
	}

err_exit:
	return err;
}

Question: Is this code saf...
→ Sample 114/236 | True: vul | Pred: nonvul | Output: // don't replicate the quickfix buffer.
		if (bt_quickfix(curbuf))
		    goto ne...
→ Sample 115/236 | True: vul | Pred: vul | Output: ptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * ...
→ Sample 116/236 | True: vul | Pred: nonvul | Output: Code: R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bi...
[VUL] Sample 130/236 [len=296]
→ Sample 117/236 | True: vul | Pred: nonvul | Output: we allow the issuer to be a
			 * quoted string.  This is not a valid GSER forma...
→ Sample 118/236 | True: vul | Pred: nonvul | Output: memory_write) {
            s->dma_memory_write(s->dma_opaque,
                 ...
→ Sample 119/236 | True: vul | Pred: vul | Output: Code: static void parse_rtcp_bye(pjmedia_rtcp_session *sess,
			   const void *p...
→ Sample 120/236 | True: vul | Pred: vul | Output: = '\0';
			if (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {
				// Null-terminate...
→ Sample 121/236 | True: vul | Pred: vul | Output: pos, new_prod_pos);

	spin_unlock_irqrestore(&rb->spinlock, flags);

	return (vo...
→ Sample 122/236 | True: vul | Pred: nonvul | Output: arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);
      if (a...
→ Sample 123/236 | True: vul | Pred: vul | Output: io_sync_cancel(struct io_uring_task *tctx,
			    struct io_cancel_data *cd, int...
→ Sample 124/236 | True: vul | Pred: nonvul | Output: ->neighbors_start[facet].neighbor[edge1] = neighbor2;
    stl->neighbors_start[f...
→ Sample 125/236 | True: vul | Pred: nonvul | Output: Code: stl_update_connects_remove_1(stl_file *stl, int facet_num) {
  int j;

  i...
→ Sample 126/236 | True: vul | Pred: nonvul | Output: * we have to wait for all existing users to finish.
	 */
	if (!refcount_dec_and_...
[VUL] Sample 140/236 [len=198]
→ Sample 127/236 | True: vul | Pred: vul | Output: Code: struct vfsmount *clone_private_mount(const struct path *path)
{
	struct mo...
→ Sample 128/236 | True: vul | Pred: nonvul | Output: }

Question: Is this code safe or vulnerable?
Answer: It's safe.

Question: Why?...
→ Sample 129/236 | True: vul | Pred: vul | Output: Code: static inline void fuse_make_bad(struct inode *inode)
{
	set_bit(FUSE_I_BA...
→ Sample 130/236 | True: vul | Pred: nonvul | Output: )
		return;

	/*
	 * We have now ensured that nobody can start using ap from now...
→ Sample 131/236 | True: vul | Pred: nonvul | Output: (dl_type == htons(ETH_TYPE_IPV6) &&
                          ipf_is_valid_v6_fr...
→ Sample 132/236 | True: vul | Pred: nonvul | Output: RBinSymbol *s = bin_symbol_from_symbol (element, sym);
			if (s) {
				r_list_ap...
→ Sample 133/236 | True: vul | Pred: vul | Output: Code: gpg_ctx_add_recipient (struct _GpgCtx *gpg,
                       const g...
→ Sample 134/236 | True: vul | Pred: vul | Output: Code: static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)
{
	int rlen,...
→ Sample 135/236 | True: vul | Pred: nonvul | Output: OPT_EXPORT_NAME) {
      nbdkit_error ("client lacks fixed newstyle support, but...
→ Sample 136/236 | True: vul | Pred: nonvul | Output: LINE|VALID_BOTLINE_AP;
	curwin->w_scbind_pos = 1;
	return;
    }

    /*
     * ...
[VUL] Sample 150/236 [len=512]
→ Sample 137/236 | True: vul | Pred: vul | Output: Index<maxVertices) {
                vertices[4*vertexIndex + (groupCode/10-1)] ...
→ Sample 138/236 | True: vul | Pred: vul | Output: Code: static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)
{
	...
→ Sample 139/236 | True: vul | Pred: vul | Output: {CMDOPT_DEBUG, "debug", 0},
		{CMDOPT_CMPTNO, "cmptno", 0},
		{CMDOPT_SRGB, "srg...
→ Sample 140/236 | True: vul | Pred: vul | Output: Code: static ssize_t remove_slot_store(struct kobject *kobj,
				 struct kobj_at...
→ Sample 141/236 | True: vul | Pred: vul | Output: Code: static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute ...
→ Sample 142/236 | True: vul | Pred: vul | Output: Code: static SQInteger thread_call(HSQUIRRELVM v)
{
    SQObjectPtr o = stack_ge...
→ Sample 143/236 | True: vul | Pred: nonvul | Output: LOG("%s is not a valid BMP file", filename);
		  at_exception_fatal(&exp, "bmp: ...
→ Sample 144/236 | True: vul | Pred: vul | Output: free(name);
			}
		}
	}

	return buf;
}

Code: static const ut8 *parse_attr_valu...
→ Sample 145/236 | True: vul | Pred: nonvul | Output: Code: TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {
  au...
→ Sample 146/236 | True: vul | Pred: vul | Output: .end()) {
    throw runtime_error("Tried to listen twice on the same path");
  }...
[VUL] Sample 160/236 [len=107]
→ Sample 147/236 | True: vul | Pred: nonvul | Output: Code: display_dollar(colnr_T col)
{
    colnr_T save_col;

    if (!redrawing())...
→ Sample 148/236 | True: vul | Pred: vul | Output: (page);
	buf->page = page;
	buf->offset = offset;
	buf->len = bytes;

	pipe->hea...
→ Sample 149/236 | True: vul | Pred: vul | Output: ->len;
		iter_head++;
		pipe->head = iter_head;

		if (left == 0)
			return size...
→ Sample 150/236 | True: vul | Pred: nonvul | Output: OPT_EXPORT_NAME) {
      nbdkit_error ("client lacks fixed newstyle support, but...
[VUL] Progress: 150/236 completed, 150 with L0 data (100.0% success)
→ Sample 151/236 | True: vul | Pred: nonvul | Output: Code: void update_process_times(int user_tick)
{
	struct task_struct *p = curren...
→ Sample 152/236 | True: vul | Pred: vul | Output: Code: inline int nci_request(struct nci_dev *ndev,
		       void (*req)(struct n...
→ Sample 153/236 | True: vul | Pred: vul | Output: (pols[i]->action != XFRM_POLICY_ALLOW) {
			*num_xfrms = -1;
			break;
		}
	}

	...
→ Sample 154/236 | True: vul | Pred: vul | Output: _to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {
				ret = -EFAU...
→ Sample 155/236 | True: vul | Pred: nonvul | Output: 0) {
      log_warn(LD_DIR, "Invalid flavor name in network-status header");
   ...
→ Sample 156/236 | True: vul | Pred: nonvul | Output: {
	    if (nbchars + 1 > buffer_size) {
		growBuffer(buffer, buffer_size);
	    ...
[VUL] Sample 170/236 [len=512]
→ Sample 157/236 | True: vul | Pred: nonvul | Output: Code: static RzList *relocs(RzBinFile *bf) {
	rz_return_val_if_fail(bf && bf->o,...
→ Sample 158/236 | True: vul | Pred: nonvul | Output: Code: PlayerGeneric::~PlayerGeneric()
{
	if (mixer)
		delete mixer;

	if (player...
→ Sample 159/236 | True: vul | Pred: nonvul | Output: Code: virNodeDeviceGetMdevTypesCaps(const char *sysfspath,
                     ...
→ Sample 160/236 | True: vul | Pred: nonvul | Output: Code: void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)
{
	minify = d...
→ Sample 161/236 | True: vul | Pred: nonvul | Output: lnum = qf_get_cur_idx(eap);
#endif
			break;
		    case ADDR_QUICKFIX_VALID_RELA...
→ Sample 162/236 | True: vul | Pred: vul | Output: Code: static void singlevar (LexState *ls, expdesc *var) {
  TString *varname = ...
→ Sample 163/236 | True: vul | Pred: nonvul | Output: e)
		goto out;
	for (i = 0; i < sh.sh_properties; i++) {
		inp->pi_name = CAST(c...
→ Sample 164/236 | True: vul | Pred: nonvul | Output: 1] = '\0';

	/* zero-out the static buffer */
	memset(tmp_pass, 0, strlen(tmp_pa...
→ Sample 165/236 | True: vul | Pred: nonvul | Output: return gdImageRotateBicubicFixed(src, angle, bgcolor);
			break;

		default:
			...
→ Sample 166/236 | True: vul | Pred: vul | Output: Code: static void *seq_buf_alloc(unsigned long size)
{
	return kvmalloc(size, GF...
[VUL] Sample 180/236 [len=290]
→ Sample 167/236 | True: vul | Pred: nonvul | Output: fa)->actions_len;
	acts->orig_len = (*sfa)->orig_len;
	kfree(*sfa);
	*sfa = acts...
→ Sample 168/236 | True: vul | Pred: nonvul | Output: Code: void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)
{
    if (!block...
→ Sample 169/236 | True: vul | Pred: vul | Output: Code: static int i2c_ddc_rx(I2CSlave *i2c)
{
    I2CDDCState *s = I2CDDC(i2c);

...
→ Sample 170/236 | True: vul | Pred: nonvul | Output: number of attributes
     * and the attribute values.
     */
    for (i = 0; i ...
→ Sample 171/236 | True: vul | Pred: vul | Output: int right_width)
{
    byte *ptr_out_temp = dest_strip;
    int ii;

    /* Left...
→ Sample 172/236 | True: vul | Pred: nonvul | Output: Code: vhost_backend_cleanup(struct virtio_net *dev)
{
	if (dev->mem) {
		free_me...
→ Sample 173/236 | True: vul | Pred: nonvul | Output: rp */
	vch->vrp = vrp;

	/* Assign public information to the rpmsg_device */
	rp...
→ Sample 174/236 | True: vul | Pred: nonvul | Output: _lock_irq(&disc_data_lock);
	ax = tty->disc_data;
	tty->disc_data = NULL;
	write...
→ Sample 175/236 | True: vul | Pred: nonvul | Output: */
    if (magick[0] != 'B' && magick[0] != 'b')
      ThrowReaderException(Corr...
→ Sample 176/236 | True: vul | Pred: nonvul | Output: */
    if (magick[0] != 'B' && magick[0] != 'b')
      ThrowReaderException(Corr...
[VUL] Sample 190/236 [len=512]
→ Sample 177/236 | True: vul | Pred: vul | Output: (asprintf(&oldLog, "%s%s", logFileName, suffix) == -1)) {
                FatalE...
→ Sample 178/236 | True: vul | Pred: vul | Output: Code: e1000_send_packet(E1000State *s, const uint8_t *buf, int size)
{
    stati...
→ Sample 179/236 | True: vul | Pred: nonvul | Output: return NULL;
    }

    h_virt = __get_clean_virt(info, addr);
    h_virt += slo...
→ Sample 180/236 | True: vul | Pred: vul | Output: _start(ap, fmt);
    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof...
→ Sample 181/236 | True: vul | Pred: vul | Output: ji->anon_inode_list));

	spin_lock_irq(&ji->ag_lock);
	if (ji->active_ag != -1) ...
→ Sample 182/236 | True: vul | Pred: vul | Output: loop, we need to save the current line number
    // and the current line in the...
→ Sample 183/236 | True: vul | Pred: vul | Output: Code: static int nft_set_desc_concat_parse(const struct nlattr *attr,
				     s...
→ Sample 184/236 | True: vul | Pred: nonvul | Output: Code: static void atusb_disconnect(struct usb_interface *interface)
{
	struct at...
→ Sample 185/236 | True: vul | Pred: nonvul | Output: = value;
			}
		}
	}

	/* error cleanup and return macro */
#define	RETURN(code)...
→ Sample 186/236 | True: vul | Pred: nonvul | Output: lnum = curwin->w_cursor.lnum;
    }
}

Question: Is this code safe or vulnerable...
[VUL] Sample 200/236 [len=284]
→ Sample 187/236 | True: vul | Pred: vul | Output: Code: static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {
  char *na...
→ Sample 188/236 | True: vul | Pred: nonvul | Output: is_valid_config(dev->hs_config, total) ||
				total > length - USB_DT_DEVICE_SIZ...
→ Sample 189/236 | True: vul | Pred: vul | Output: = 1;
	mctvalid = false;

	if (optstr) {
		if (jas_tvparser_parse(optstr, &tvp)) ...
→ Sample 190/236 | True: vul | Pred: vul | Output: \0"))
                    break;
            }
            if (k == 64)
        ...
→ Sample 191/236 | True: vul | Pred: nonvul | Output: if (image_info == (ImageInfo *) NULL)
    ThrowReaderException(UndefinedExceptio...
→ Sample 192/236 | True: vul | Pred: nonvul | Output: kfree(ctx);
	nft_flow_rule_destroy(flow);

	return ERR_PTR(err);
}

Question: Is...
→ Sample 193/236 | True: vul | Pred: nonvul | Output: .0 */
  if (uri == NULL) {
    len = 0;
  } else {
    len = (int)strlen(uri);
 ...
→ Sample 194/236 | True: vul | Pred: nonvul | Output: type box\n");
		goto error;
	}
	if (box->data.ftyp.magic != JP2_FTYP_MAGIC) {
		...
→ Sample 195/236 | True: vul | Pred: vul | Output: /* allocate memory for symbols data in each CDIC record */
    huffcdic->symbols...
→ Sample 196/236 | True: vul | Pred: nonvul | Output: Code: disable_priv_mode ()
{
  int e;

  if (setuid (current_user.uid) < 0)
    ...
[VUL] Sample 210/236 [len=134]
→ Sample 197/236 | True: vul | Pred: nonvul | Output: _irq irq;
	int ret, vector;

	if (sint >= ARRAY_SIZE(synic->sint))
		return -EIN...
→ Sample 198/236 | True: vul | Pred: nonvul | Output: if (strncasecmp (ptr, "icecast-auth-message: ", 22) == 0)
        {
            ...
→ Sample 199/236 | True: vul | Pred: vul | Output: Code: append_command(char_u *cmd)
{
    char_u *s = cmd;
    char_u *d;

    STR...
→ Sample 200/236 | True: vul | Pred: nonvul | Output: ;

    cursor_save = curwin->w_cursor;
    while ((trypos = findmatchlimit(NULL,...
[VUL] Progress: 200/236 completed, 200 with L0 data (100.0% success)
→ Sample 201/236 | True: vul | Pred: vul | Output: Code: http_isfiltered(const struct http *fm, unsigned u, unsigned how)
{
	const ...
→ Sample 202/236 | True: vul | Pred: nonvul | Output: _MOD(n, "no priority provided");
			return -EINVAL;
		}
	}

	if (tca[TCA_TC_FLAG...
→ Sample 203/236 | True: vul | Pred: vul | Output: Code: static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)
{
	u32 ...
→ Sample 204/236 | True: vul | Pred: vul | Output: Code: int hci_conn_check_link_mode(struct hci_conn *conn)
{
	BT_DBG("hcon %p", c...
→ Sample 205/236 | True: vul | Pred: vul | Output: (a > REGIONAL_LARGE_OBJECT_SIZE) {
		s = malloc(ALIGNMENT + size);
		if(!s) retu...
→ Sample 206/236 | True: vul | Pred: nonvul | Output: *buf,
				       const pj_stun_msg_hdr *msghdr, 
				       void **p_attr)
{
   ...
[VUL] Sample 220/236 [len=215]
→ Sample 207/236 | True: vul | Pred: vul | Output: Code: pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)
{
    uint ...
→ Sample 208/236 | True: vul | Pred: nonvul | Output: if (qftf_li != NULL)
	    {
		qftf_str = qftf_li->lv_data;
		qftf_li = qftf_li->...
→ Sample 209/236 | True: vul | Pred: nonvul | Output: Yes, it is safe.
→ Sample 210/236 | True: vul | Pred: vul | Output: Code: static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,
       ...
→ Sample 211/236 | True: vul | Pred: nonvul | Output: Code: void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)
{
	struct nc...
→ Sample 212/236 | True: vul | Pred: vul | Output: +13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}

Ques...
→ Sample 213/236 | True: vul | Pred: nonvul | Output: }

Question: Is this code safe or vulnerable?
Answer: It is safe.
→ Sample 214/236 | True: vul | Pred: nonvul | Output: Code: FindEmptyObjectSlot(
		    TPMI_DH_OBJECT  *handle         // OUT: (option...
→ Sample 215/236 | True: vul | Pred: nonvul | Output: *ptr++;
	y = *ptr++;
	w = *ptr++;
	h = *ptr++;

	client->GotFillRect(client, rx+...
→ Sample 216/236 | True: vul | Pred: vul | Output: Code: find_next_quote(
    char_u	*line,
    int		col,
    int		quotechar,
    c...
[VUL] Sample 230/236 [len=434]
→ Sample 217/236 | True: vul | Pred: vul | Output: sadb_msg_satype))
			return -EEXIST;
		pfk->registered |= (1<<hdr->sadb_msg_saty...
→ Sample 218/236 | True: vul | Pred: vul | Output: str) {
         simplestring_init_str(target);
      }
      if(target->len + ad...
→ Sample 219/236 | True: vul | Pred: vul | Output: nsock_printf(sd, "%-10s %s\n", qh->name, qh->description ? qh->description : "(N...
→ Sample 220/236 | True: vul | Pred: vul | Output: Code: static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,
			...
→ Sample 221/236 | True: vul | Pred: vul | Output: Code: setup_secureChannel(void) {
    TestingPolicy(&dummyPolicy, dummyCertifica...
→ Sample 222/236 | True: vul | Pred: vul | Output: Code: void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len)...
[VUL] Sample 236/236 [len=399]
→ Sample 223/236 | True: vul | Pred: nonvul | Output: get_buffer(s, desc) != p) {
                DB_PRINT("Invalid TX descriptor @ 0x...
→ Sample 224/236 | True: vul | Pred: vul | Output: if (copy_from_user(authkey, optval, optlen)) {
		ret = -EFAULT;
		goto out;
	}

...
→ Sample 225/236 | True: vul | Pred: nonvul | Output: Code: static sctp_disposition_t sctp_sf_violation_paramlen(
				     const struc...
→ Sample 226/236 | True: vul | Pred: nonvul | Output: ,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type...
→ Sample 227/236 | True: vul | Pred: nonvul | Output: }.  If @var{mode} is omitted\n"
	    "then the permissions of the directory file...
→ Sample 228/236 | True: vul | Pred: vul | Output: Code: rpa_read_buffer(pool_t pool, const unsigned char **data,
		const unsigned ...
→ Sample 229/236 | True: vul | Pred: nonvul | Output: Code: int setup_tests(void)
{
    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_f...
→ Sample 230/236 | True: vul | Pred: nonvul | Output: }
  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));
  ...
→ Sample 231/236 | True: vul | Pred: vul | Output: Code: void ha_maria::drop_table(const char *name)
{
  DBUG_ASSERT(file->s->tempo...
→ Sample 232/236 | True: vul | Pred: vul | Output: length= strlen(table_list->alias.str);
  key= table_list->alias.str;

  /*
    C...
→ Sample 233/236 | True: vul | Pred: vul | Output: Code: static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)
{
  const size_t s...
→ Sample 234/236 | True: vul | Pred: nonvul | Output: new_field->vcol_info= 0;
    new_field->cond_selectivity= 1.0;
    new_field->ne...
→ Sample 235/236 | True: vul | Pred: vul | Output: It is vulnerable to a race condition.
→ Sample 236/236 | True: vul | Pred: nonvul | Output: StringBuffer_append(res->outputbuffer,
                                    "<b>C...
[INFO] Processing 236 NONVUL samples (optimized GPU utilization)
[NONVUL] Sample 1/236 [len=424]
[NONVUL] Sample 10/236 [len=61]
→ Sample 1/236 | True: nonvul | Pred: nonvul | Output: Yes, it is safe.

Code: CellularNetwork::CellularNetwork(const ServiceInfo* serv...
→ Sample 2/236 | True: nonvul | Pred: nonvul | Output: Code: void Network::Clear() {
  state_ = STATE_UNKNOWN;
  error_ = ERROR_UNKNOWN...
→ Sample 3/236 | True: nonvul | Pred: nonvul | Output: Code: virtual void EnableOfflineMode(bool enable) {
    if (!EnsureCrosLoaded())...
→ Sample 4/236 | True: nonvul | Pred: nonvul | Output: IPConfig ipconfig = ipconfig_status->ips[i];
          ipconfig_vector.push_back...
→ Sample 5/236 | True: nonvul | Pred: nonvul | Output: Code: std::string CellularNetwork::GetRoamingStateString() const {
  switch (thi...
→ Sample 6/236 | True: nonvul | Pred: nonvul | Output: (service->device_path);
  is_active_ = service->is_active;
  ip_address_.clear()...
[NONVUL] Sample 20/236 [len=149]
→ Sample 7/236 | True: nonvul | Pred: nonvul | Output: (technology == kNetworkTechnologyGprs)
    return NETWORK_TECHNOLOGY_GPRS;
  if ...
→ Sample 8/236 | True: nonvul | Pred: nonvul | Output: Code: virtual void RemoveObserverForAllNetworks(NetworkObserver* observer) {
   ...
→ Sample 9/236 | True: nonvul | Pred: nonvul | Output: Code: virtual void RequestWifiScan() {
    if (EnsureCrosLoaded()) {
      Reque...
→ Sample 10/236 | True: nonvul | Pred: nonvul | Output: Code: void UpdateCellularDataPlan(const CellularDataPlanList* data_plans) {
    ...
→ Sample 11/236 | True: nonvul | Pred: nonvul | Output: } else if (strcmp(key, kNetworkTypeProperty) == 0) {
          if (value->GetAsS...
→ Sample 12/236 | True: nonvul | Pred: nonvul | Output: Code: WirelessNetwork::WirelessNetwork(const WirelessNetwork& network)
    : Net...
→ Sample 13/236 | True: nonvul | Pred: nonvul | Output: Code: bool CellularNetwork::is_gsm() const {
  return network_technology_ != NET...
→ Sample 14/236 | True: nonvul | Pred: nonvul | Output: Code: void CountOriginType(const std::set<GURL>& origins,
                     S...
→ Sample 15/236 | True: nonvul | Pred: nonvul | Output: Code: QuotaManager::UsageAndQuotaDispatcherTask::Create(
    QuotaManager* manag...
→ Sample 16/236 | True: nonvul | Pred: nonvul | Output: Code: void QuotaManager::DidGetAvailableSpaceForEviction(
    QuotaStatusCode st...
[NONVUL] Sample 30/236 [len=110]
→ Sample 17/236 | True: nonvul | Pred: nonvul | Output: Code: void DidGetGlobalQuota(QuotaStatusCode status,
                         St...
→ Sample 18/236 | True: nonvul | Pred: nonvul | Output: HostQuota(QuotaStatusCode status,
                       const std::string& host...
→ Sample 19/236 | True: nonvul | Pred: nonvul | Output: ) {
  DCHECK_EQ(type, kStorageTypeTemporary);
  scoped_refptr<InitializeTemporar...
→ Sample 20/236 | True: nonvul | Pred: nonvul | Output: return;
    default:
      NOTREACHED();
  }
}

Question: Is this code safe or v...
→ Sample 21/236 | True: nonvul | Pred: nonvul | Output: It's safe.
→ Sample 22/236 | True: nonvul | Pred: nonvul | Output: Code: GetModifiedSinceTask(
      QuotaManager* manager,
      StorageType type,...
→ Sample 23/236 | True: nonvul | Pred: nonvul | Output: Code: void QuotaManager::GetOriginsModifiedSince(
    StorageType type,
    base...
→ Sample 24/236 | True: nonvul | Pred: nonvul | Output: (temporary_global_quota_ >= 0) {
    callback->Run(kQuotaStatusOk,
             ...
→ Sample 25/236 | True: nonvul | Pred: nonvul | Output: has_registered_origins_(false) {
    DCHECK(temporary_usage_tracker);
    tempor...
→ Sample 26/236 | True: nonvul | Pred: nonvul | Output: Code: QuotaCallback* NewWaitableGlobalQuotaCallback() {
    ++waiting_callbacks_...
[NONVUL] Sample 40/236 [len=54]
→ Sample 27/236 | True: nonvul | Pred: nonvul | Output: Code: void QuotaManager::NotifyOriginInUse(const GURL& origin) {
  DCHECK(io_thr...
→ Sample 28/236 | True: nonvul | Pred: nonvul | Output: It's safe.

Code: void QuotaManagerProxy::NotifyStorageAccessed(
    QuotaClient...
→ Sample 29/236 | True: nonvul | Pred: nonvul | Output: }

Question: Is this code safe or vulnerable?
Answer: It is safe.
→ Sample 30/236 | True: nonvul | Pred: nonvul | Output: _THIS_IN_INITIALIZER_LIST(this)) {}

Question: Is this code safe or vulnerable?
...
→ Sample 31/236 | True: nonvul | Pred: nonvul | Output: base::Time accessed_time)
      : DatabaseTaskBase(manager),
        origin_(ori...
→ Sample 32/236 | True: nonvul | Pred: nonvul | Output: Code: UsageAndQuotaDispatcherTaskForTemporary(
      QuotaManager* manager, cons...
→ Sample 33/236 | True: nonvul | Pred: nonvul | Output: proxy(),
                                 mock_data, mock_data_size);
  }

Quest...
→ Sample 34/236 | True: nonvul | Pred: nonvul | Output: type;
    usage_ = usage;
    unlimited_usage_ = unlimited_usage;
  }

Question:...
→ Sample 35/236 | True: nonvul | Pred: nonvul | Output: {
    host_ = host;
    type_ = type;
    usage_ = usage;
  }

Question: Is this...
→ Sample 36/236 | True: nonvul | Pred: nonvul | Output: URL>& origins, StorageType type) {
    modified_origins_ = origins;
    modified...
[NONVUL] Sample 50/236 [len=215]
→ Sample 37/236 | True: nonvul | Pred: nonvul | Output: Code: void DidGetUsageAndQuotaAdditional(
      QuotaStatusCode status, int64 us...
→ Sample 38/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 39/236 | True: nonvul | Pred: nonvul | Output: &QuotaManagerTest::DidGetAvailableSpace));
  }

Question: Is this code safe or v...
→ Sample 40/236 | True: nonvul | Pred: nonvul | Output: QuotaManagerTest()
      : callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this...
→ Sample 41/236 | True: nonvul | Pred: nonvul | Output: Code: void SetTemporaryGlobalQuota(int64 new_quota) {
    quota_status_ = kQuota...
→ Sample 42/236 | True: nonvul | Pred: nonvul | Output: Code: void ClientUsageTracker::GetCachedOrigins(std::set<GURL>* origins) const {...
→ Sample 43/236 | True: nonvul | Pred: nonvul | Output: 0;
    global_usage_.unlimited_usage = 0;
    for (ClientTrackerMap::iterator it...
→ Sample 44/236 | True: nonvul | Pred: nonvul | Output: Code: bool ClientUsageTracker::IsStorageUnlimited(const GURL& origin) const {
  ...
→ Sample 45/236 | True: nonvul | Pred: nonvul | Output: Code: void ClientUsageTracker::OnSpecialStoragePolicyChanged() {
  DCHECK(Called...
→ Sample 46/236 | True: nonvul | Pred: nonvul | Output: Code: bool SortByHost(const GURL& lhs, const GURL& rhs) {
  return net::GetHostO...
[NONVUL] Sample 60/236 [len=65]
→ Sample 47/236 | True: nonvul | Pred: nonvul | Output: delta;
    if (global_unlimited_usage_is_valid_ && IsStorageUnlimited(origin))
 ...
→ Sample 48/236 | True: nonvul | Pred: nonvul | Output: Yes, it is safe.
→ Sample 49/236 | True: nonvul | Pred: nonvul | Output: AddSetRegValueWorkItem(root, version_key,
                               google_...
→ Sample 50/236 | True: nonvul | Pred: nonvul | Output: _refresh_policy();
    } else {
      VLOG(1) << kIERefreshPolicy << " not suppo...
[NONVUL] Progress: 50/236 completed, 50 with L0 data (100.0% success)
→ Sample 51/236 | True: nonvul | Pred: nonvul | Output: Code: bool decode(ArgumentDecoder* decoder, RetainPtr<CFDataRef>& result)
{
    ...
→ Sample 52/236 | True: nonvul | Pred: nonvul | Output: It's safe.

Code: static CFTypeRef typeFromCFType(CFType type)
{
    ASSERT(type...
→ Sample 53/236 | True: nonvul | Pred: vul | Output: Code: void WebProcessProxy::addMessageReceiver(CoreIPC::StringReference messageR...
→ Sample 54/236 | True: nonvul | Pred: vul | Output: Code: void WebProcessProxy::addMessageReceiver(CoreIPC::StringReference messageR...
→ Sample 55/236 | True: nonvul | Pred: nonvul | Output: ;
}

Question: Is this code safe or vulnerable?
Answer: It is safe.
→ Sample 56/236 | True: nonvul | Pred: nonvul | Output: Code: void WebProcessProxy::didFinishLaunching(ProcessLauncher* launcher, CoreIP...
[NONVUL] Sample 70/236 [len=100]
→ Sample 57/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 58/236 | True: nonvul | Pred: nonvul | Output: OnConnectionWorkQueue(CoreIPC::Connection* connection, CoreIPC::MessageID messag...
→ Sample 59/236 | True: nonvul | Pred: vul | Output: Code: void WebProcessProxy::getSharedWorkerProcessConnection(const String& /* ur...
→ Sample 60/236 | True: nonvul | Pred: vul | Output: Code: void WebProcessProxy::removeMessageReceiver(CoreIPC::StringReference messa...
→ Sample 61/236 | True: nonvul | Pred: nonvul | Output: #endif

    send(Messages::WebProcess::DidGetPlugins(requestID, *plugins), 0);
}...
→ Sample 62/236 | True: nonvul | Pred: nonvul | Output: Code: v8::Handle<v8::Value> V8ThrowException::createRangeError(v8::Isolate* isol...
→ Sample 63/236 | True: nonvul | Pred: nonvul | Output: Code: std::unique_ptr<content::OverlayWindow> content::OverlayWindow::Create(
  ...
→ Sample 64/236 | True: nonvul | Pred: nonvul | Output: Code: gfx::Rect OverlayWindowViews::GetFirstCustomControlsBounds() {
  if (!firs...
→ Sample 65/236 | True: nonvul | Pred: nonvul | Output: Code: bool OverlayWindowViews::HasOnlyOneCustomControl() {
  return first_custom...
→ Sample 66/236 | True: nonvul | Pred: nonvul | Output: It is safe.

Code: void OverlayWindowViews::UpdateButtonPosition() {
  const gfx...
[NONVUL] Sample 80/236 [len=512]
→ Sample 67/236 | True: nonvul | Pred: nonvul | Output: & natural_size) {
  DCHECK(!natural_size.IsEmpty());
  natural_size_ = natural_s...
→ Sample 68/236 | True: nonvul | Pred: nonvul | Output: Code: views::View* OverlayWindowViews::controls_parent_view_for_testing() const ...
→ Sample 69/236 | True: nonvul | Pred: nonvul | Output: );
     updateProcessSuppressionState();
 #endif
}

Question: Is this code safe ...
→ Sample 70/236 | True: nonvul | Pred: nonvul | Output: ) << "chromeos_library calls made from non UI thread!";
      NOTREACHED();
    ...
→ Sample 71/236 | True: nonvul | Pred: nonvul | Output: Code: virtual CellularNetwork* FindCellularNetworkByPath(
      const std::strin...
→ Sample 72/236 | True: nonvul | Pred: nonvul | Output: ) {
    NetworkLibraryImpl* networklib = static_cast<NetworkLibraryImpl*>(object...
→ Sample 73/236 | True: nonvul | Pred: nonvul | Output: Code: void NotifyCellularDataPlanChanged() {
    FOR_EACH_OBSERVER(CellularDataP...
→ Sample 74/236 | True: nonvul | Pred: nonvul | Output: Code: AvailableSpaceQueryTask(
      QuotaManager* manager,
      scoped_refptr<...
→ Sample 75/236 | True: nonvul | Pred: nonvul | Output: Code: bool QuotaManager::ResetUsageTracker(StorageType type) {
  switch (type) {...
→ Sample 76/236 | True: nonvul | Pred: nonvul | Output: Code: GatherUsageTaskBase(
      UsageTracker* tracker,
      QuotaClient* clien...
[NONVUL] Sample 90/236 [len=445]
→ Sample 77/236 | True: nonvul | Pred: nonvul | Output: Code: WebBackForwardListItem* WebProcessProxy::webBackForwardItem(uint64_t itemI...
→ Sample 78/236 | True: nonvul | Pred: nonvul | Output: Code: gfx::Point OverlayWindowViews::close_image_position_for_testing() const {
...
→ Sample 79/236 | True: nonvul | Pred: nonvul | Output: void *) image->properties,property,value,
        exception);
      break;
    }...
→ Sample 80/236 | True: nonvul | Pred: nonvul | Output: if (LocaleCompare("color-map",property) == 0)
        {
          /*
           ...
→ Sample 81/236 | True: nonvul | Pred: nonvul | Output: t) ReadPropertyMSBShort(&blob,&length);
        if (knot_count == 0)
          {...
→ Sample 82/236 | True: nonvul | Pred: nonvul | Output: Code: MagickExport MagickBooleanType DefineImageProperty(Image *image,
  const c...
→ Sample 83/236 | True: nonvul | Pred: nonvul | Output: if (SyncAuthenticPixels(image,exception) == MagickFalse)
      status=MagickFals...
→ Sample 84/236 | True: nonvul | Pred: nonvul | Output: Code: static size_t WriteCompressionStart(const PSDInfo *psd_info,Image *image,
...
→ Sample 85/236 | True: nonvul | Pred: nonvul | Output: Code: static inline ssize_t WritePSDSize(const PSDInfo *psd_info,Image *image,
 ...
→ Sample 86/236 | True: nonvul | Pred: vul | Output: Code: static void XDrawBeveledMatte(Display *display,const XWindowInfo *window_i...
[NONVUL] Sample 100/236 [len=81]
→ Sample 87/236 | True: nonvul | Pred: nonvul | Output: Code: ImmutableExecutorState::~ImmutableExecutorState() {
  for (int32_t i = 0; ...
→ Sample 88/236 | True: nonvul | Pred: nonvul | Output: : graph->nodes()) {
    if (IsSink(n)) continue;
    const int id = n->id();
   ...
→ Sample 89/236 | True: nonvul | Pred: nonvul | Output: vector<OpInfo::TensorProperties>& output_props =
        properties->GetOutputPr...
→ Sample 90/236 | True: nonvul | Pred: nonvul | Output: _back(value.vec<int64_t>()(j));
      } else {
        shape->push_back(value.ve...
→ Sample 91/236 | True: nonvul | Pred: nonvul | Output: TF_RETURN_IF_ERROR(
      SimplifyGraph(optimized_graph, properties, &nodes_to_n...
→ Sample 92/236 | True: nonvul | Pred: nonvul | Output: Code: void ConstantFolding::ReplaceSubtractionFromZeroByNegation(NodeDef* node,
...
→ Sample 93/236 | True: nonvul | Pred: nonvul | Output: , just route the
  // input around it.
  if (IsIdentity(*node)) {
    NodeDef* i...
→ Sample 94/236 | True: nonvul | Pred: nonvul | Output: Code: float QuantizedTypeMaxAsFloat(DataType data_type) {
  switch (data_type) {...
→ Sample 95/236 | True: nonvul | Pred: nonvul | Output: Code: static Status PutValueIntoTensor(const int64_t value, const DataType& type...
→ Sample 96/236 | True: nonvul | Pred: nonvul | Output: }
    if (replaceable) {
      ReplaceOperationWithIdentity(0, properties, node,...
[NONVUL] Sample 110/236 [len=280]
→ Sample 97/236 | True: nonvul | Pred: nonvul | Output: Code: bool ConstantFolding::GetTensorFromConstNode(const string& node_name_or_in...
→ Sample 98/236 | True: nonvul | Pred: nonvul | Output: ;
  }
  node->set_op("Identity");
  EraseRegularNodeAttributes(node);
  (*node->...
→ Sample 99/236 | True: nonvul | Pred: nonvul | Output: Code: bool ConstantFolding::OptimizedNodeExists(const NodeDef& node,
           ...
→ Sample 100/236 | True: nonvul | Pred: nonvul | Output: Code: Status ConstantFolding::EvaluateNode(const NodeDef& node,
                ...
[NONVUL] Progress: 100/236 completed, 100 with L0 data (100.0% success)
→ Sample 101/236 | True: nonvul | Pred: nonvul | Output: Code: bool ConstantFolding::IsReallyConstant(const NodeDef& node) const {
  if (...
→ Sample 102/236 | True: nonvul | Pred: nonvul | Output: ConstantFolding::ReplaceDivisionOfOnesByReciprocal(NodeDef* node,
              ...
→ Sample 103/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 104/236 | True: nonvul | Pred: nonvul | Output: Code: ConstantFolding::ConstantFolding(RewriterConfig::Toggle opt_level,
       ...
→ Sample 105/236 | True: nonvul | Pred: nonvul | Output: input()->SwapElements(0, input_to_forward);
  // Add all other inputs as control...
→ Sample 106/236 | True: nonvul | Pred: nonvul | Output: , node));
  SET_AND_RETURN_IF_MODIFIED(
      SimplifyConstantFolding(optimized_...
[NONVUL] Sample 120/236 [len=95]
→ Sample 107/236 | True: nonvul | Pred: nonvul | Output: Code: Bool IsHintTrack(GF_TrackBox *trak)
{
	if (trak->Media->handler->handlerTy...
→ Sample 108/236 | True: nonvul | Pred: nonvul | Output: ->udta, GF_ISOM_BOX_TYPE_HNTI, NULL);
	if (!map) return GF_ISOM_INVALID_FILE;

	...
→ Sample 109/236 | True: nonvul | Pred: nonvul | Output: ent = (GF_SeqOffHintEntryBox *) gf_isom_box_new_parent(&hdesc->child_boxes, GF_I...
→ Sample 110/236 | True: nonvul | Pred: nonvul | Output: offset = gf_isom_hint_sample_size(entry->hint_sample) - entry->hint_sample->data...
→ Sample 111/236 | True: nonvul | Pred: nonvul | Output: to create a new entry...
	ent = (GF_TimeOffHintEntryBox *) gf_isom_box_new_paren...
→ Sample 112/236 | True: nonvul | Pred: nonvul | Output: char b;
		char *st = strstr(cur, "\r\n");
		assert(st);
		st += 2;
		if (!st[0])...
→ Sample 113/236 | True: nonvul | Pred: nonvul | Output: Code: static void AddSDPLine(GF_List *list, char *sdp_text, Bool is_movie_sdp)
{...
→ Sample 114/236 | True: nonvul | Pred: nonvul | Output: pck->X_bit = eXtensionBit ? 1 : 0;
	pck->M_bit = MarkerBit ? 1 : 0;
	pck->B_bit ...
→ Sample 115/236 | True: nonvul | Pred: vul | Output: Code: Bool CheckHintFormat(GF_TrackBox *trak, u32 HintType)
{
	if (!IsHintTrack(...
→ Sample 116/236 | True: nonvul | Pred: nonvul | Output: name(), " input ", input);
    }
    inputs.push_back(value);
    total_inputs_s...
[NONVUL] Sample 130/236 [len=310]
→ Sample 117/236 | True: nonvul | Pred: nonvul | Output: Code: int callback_glewlwyd_get_user_module_list (const struct _u_request * requ...
→ Sample 118/236 | True: nonvul | Pred: nonvul | Output: f(j_result);
  } else {
    response->status = 400;
  }
  json_decref(j_profile)...
→ Sample 119/236 | True: nonvul | Pred: nonvul | Output: set_json_body_response(response, 400, json_object_get(j_module_valid, "error"));...
→ Sample 120/236 | True: nonvul | Pred: nonvul | Output: Code: int callback_404_if_necessary (const struct _u_request * request, struct _...
→ Sample 121/236 | True: nonvul | Pred: nonvul | Output: Code: int callback_glewlwyd_server_configuration (const struct _u_request * requ...
→ Sample 122/236 | True: nonvul | Pred: nonvul | Output: OK)) {
    ulfius_set_json_body_response(response, 200, json_object_get(j_api_ke...
→ Sample 123/236 | True: nonvul | Pred: nonvul | Output: }
  } else if (check_result_value(j_scheme, G_ERROR_NOT_FOUND)) {
    response->...
→ Sample 124/236 | True: nonvul | Pred: nonvul | Output: Code: int callback_glewlwyd_get_plugin_module_list (const struct _u_request * re...
→ Sample 125/236 | True: nonvul | Pred: nonvul | Output: = get_client(config, u_map_get(request->map_url, "client_id"), u_map_get(request...
→ Sample 126/236 | True: nonvul | Pred: nonvul | Output: _get(request->map_url, "name"));
  if (check_result_value(j_module, G_OK)) {
   ...
[NONVUL] Sample 140/236 [len=428]
→ Sample 127/236 | True: nonvul | Pred: nonvul | Output: j_search_module, G_ERROR_NOT_FOUND)) {
    response->status = 404;
  } else {
  ...
→ Sample 128/236 | True: nonvul | Pred: nonvul | Output: Yes, it is safe.
→ Sample 129/236 | True: nonvul | Pred: nonvul | Output: Yes, it is safe.
→ Sample 130/236 | True: nonvul | Pred: nonvul | Output: _iter->second.values;
        const auto& shape = sp_iter->second.shape;
       ...
→ Sample 131/236 | True: nonvul | Pred: nonvul | Output: Code: void Node::ClearTypeInfo() {
  if (props_->node_def.has_experimental_type(...
→ Sample 132/236 | True: nonvul | Pred: nonvul | Output: // indexed by pointer.  This would keep the size of each Node small
  // in the ...
→ Sample 133/236 | True: nonvul | Pred: nonvul | Output: Code: NodeDebugInfo::NodeDebugInfo(const NodeDef& ndef)
    : NodeDebugInfo(ndef...
→ Sample 134/236 | True: nonvul | Pred: nonvul | Output: Code: std::unordered_map<std::string, Node*> Graph::BuildNodeNameIndex() const {...
→ Sample 135/236 | True: nonvul | Pred: nonvul | Output: Code: Status Graph::IsValidInputTensor(const Node* node, int idx) const {
  TF_R...
→ Sample 136/236 | True: nonvul | Pred: nonvul | Output: _inputs()) {
      return errors::Internal("Invalid edge input number ", edge->d...
[NONVUL] Sample 150/236 [len=478]
→ Sample 137/236 | True: nonvul | Pred: nonvul | Output: Code: void Node::MaybeCopyOnWrite() {
  // TODO(mdan): As nodes become more dyna...
→ Sample 138/236 | True: nonvul | Pred: nonvul | Output: Code: AttrValue* Node::AddAttrHelper(const std::string& name) {
  MaybeCopyOnWri...
→ Sample 139/236 | True: nonvul | Pred: nonvul | Output: (node->props_, node, node->class_);
  copy->set_assigned_device_name(node->assig...
→ Sample 140/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 141/236 | True: nonvul | Pred: nonvul | Output: _SHIFT_SHARED_MIN) {
    return mrb_ary_new_from_values(mrb, len, ARY_PTR(a)+beg...
→ Sample 142/236 | True: nonvul | Pred: nonvul | Output: Code: mrb_ary_resize(mrb_state *mrb, mrb_value ary, mrb_int new_len)
{
  mrb_int...
→ Sample 143/236 | True: nonvul | Pred: nonvul | Output: _malloc(mrb, len);
      if (p) {
        array_copy(ptr, p, a->as.heap.len);
  ...
→ Sample 144/236 | True: nonvul | Pred: nonvul | Output: Code: mrb_ary_clear_m(mrb_state *mrb, mrb_value self)
{
  return mrb_ary_clear(m...
→ Sample 145/236 | True: nonvul | Pred: nonvul | Output: Code: ary_new_capa(mrb_state *mrb, mrb_int capa)
{
  struct RArray *a;
  size_t ...
→ Sample 146/236 | True: nonvul | Pred: nonvul | Output: Code: mrb_ary_index_m(mrb_state *mrb, mrb_value self)
{
  mrb_value obj = mrb_ge...
[NONVUL] Sample 160/236 [len=316]
→ Sample 147/236 | True: nonvul | Pred: nonvul | Output: v2;
  }

  mrb_get_args(mrb, "ooo", &v1, &v2, &v3);
  /* a[n,m] = v */
  mrb_ary...
→ Sample 148/236 | True: nonvul | Pred: nonvul | Output: Code: mrb_ary_new_from_values(mrb_state *mrb, mrb_int size, const mrb_value *val...
→ Sample 149/236 | True: nonvul | Pred: nonvul | Output: Code: mrb_ary_reverse_bang(mrb_state *mrb, mrb_value self)
{
  struct RArray *a ...
→ Sample 150/236 | True: nonvul | Pred: nonvul | Output: It is safe.
[NONVUL] Progress: 150/236 completed, 150 with L0 data (100.0% success)
→ Sample 151/236 | True: nonvul | Pred: nonvul | Output: , input_ptr, filter_ptr,
                                            output_ptr)...
→ Sample 152/236 | True: nonvul | Pred: nonvul | Output: ();
  }

  return XlaPlatformInfo(DeviceType(device->device_type()), platform_id...
→ Sample 153/236 | True: nonvul | Pred: nonvul | Output: Code: std::shared_ptr<se::DeviceMemoryAllocator> GetAllocator(
    DeviceBase* d...
→ Sample 154/236 | True: nonvul | Pred: nonvul | Output: Code: inline int SubscriptToIndex(const NdArrayDesc<5>& desc, int indexes[5]) {
...
→ Sample 155/236 | True: nonvul | Pred: nonvul | Output: Code: float ActivationFunction(float x) {
  float output_activation_min, output_...
→ Sample 156/236 | True: nonvul | Pred: nonvul | Output: It is safe.
[NONVUL] Sample 170/236 [len=127]
→ Sample 157/236 | True: nonvul | Pred: vul | Output: t result = x >> total_shift;
  return result;
}

Question: Is this code safe or ...
→ Sample 158/236 | True: nonvul | Pred: nonvul | Output: _DCHECK(shift >= -31 && shift <= 30);

  const int64_t total_shift = 31 - shift;...
→ Sample 159/236 | True: nonvul | Pred: nonvul | Output: _assert(std::is_unsigned<T>::value,
                "Only unsigned integer types...
→ Sample 160/236 | True: nonvul | Pred: nonvul | Output: gemmlowp::FixedPoint<int32_t, 0> shifted_scale =
      gemmlowp::one_over_one_pl...
→ Sample 161/236 | True: nonvul | Pred: nonvul | Output: Code: void optimized_ops_prefetch_write_l1_keep(const T* ptr) {
#ifdef __GNUC__
...
→ Sample 162/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 163/236 | True: nonvul | Pred: nonvul | Output: Code: inline int CountLeadingSignBits(T integer_input) {
  static_assert(std::is...
→ Sample 164/236 | True: nonvul | Pred: nonvul | Output: Code: inline int SubscriptToIndex(const NdArrayDesc<8>& desc, int indexes[8]) {
...
→ Sample 165/236 | True: nonvul | Pred: nonvul | Output: .
    GroupCrossDeviceControlEdges(/*host_granularity=*/true);
  }

  return Sta...
→ Sample 166/236 | True: nonvul | Pred: nonvul | Output: Code: const GF_FilterRegister *mpgviddmx_register(GF_FilterSession *session)
{
	...
[NONVUL] Sample 180/236 [len=76]
→ Sample 167/236 | True: nonvul | Pred: nonvul | Output: Code: GF_Err gf_odf_av1_cfg_write(GF_AV1Config *cfg, u8 **outData, u32 *outSize)...
→ Sample 168/236 | True: nonvul | Pred: nonvul | Output: 20);
		for (i = 0; i < 5; ++i) {
			if (data[i] != 0) {
				GF_LOG(GF_LOG_WARNIN...
→ Sample 169/236 | True: nonvul | Pred: nonvul | Output: Code: GF_Err gf_odf_vvc_cfg_write(GF_VVCConfig *cfg, u8 **outData, u32 *outSize)...
→ Sample 170/236 | True: nonvul | Pred: nonvul | Output: Code: GF_VVCConfig *gf_odf_vvc_cfg_new()
{
	GF_VVCConfig *cfg;
	GF_SAFEALLOC(cfg...
→ Sample 171/236 | True: nonvul | Pred: nonvul | Output: Code: GF_Err gf_odf_avc_cfg_write(GF_AVCConfig *cfg, u8 **outData, u32 *outSize)...
→ Sample 172/236 | True: nonvul | Pred: nonvul | Output: Code: GF_AV1Config *gf_odf_av1_cfg_new()
{
	GF_AV1Config *cfg;
	GF_SAFEALLOC(cfg...
→ Sample 173/236 | True: nonvul | Pred: nonvul | Output: Code: GF_Descriptor *gf_odf_new_text_cfg()
{
	GF_TextConfig *newDesc = (GF_TextC...
→ Sample 174/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 175/236 | True: nonvul | Pred: nonvul | Output: However, in this case V_IRQ will remain true until
		 * interrupt_window_interce...
→ Sample 176/236 | True: nonvul | Pred: vul | Output: Code: void nested_load_control_from_vmcb12(struct vcpu_svm *svm,
				     struct...
[NONVUL] Sample 190/236 [len=104]
→ Sample 177/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 178/236 | True: nonvul | Pred: nonvul | Output: Code: job_removed_cb (SystemdManager *manager,
                guint32         i...
→ Sample 179/236 | True: nonvul | Pred: nonvul | Output: {
      if (error)
        g_dbus_error_strip_remote_error (*error);
      retur...
→ Sample 180/236 | True: nonvul | Pred: vul | Output: Code: flatpak_run_cups_check_server_is_socket (const char *server)
{
  if (g_str...
→ Sample 181/236 | True: nonvul | Pred: nonvul | Output: will not work.
               */
              local_xa.address = unames.nodenam...
→ Sample 182/236 | True: nonvul | Pred: nonvul | Output: Code: flatpak_run_parse_pulse_server (const char *value)
{
  g_auto(GStrv) serve...
→ Sample 183/236 | True: nonvul | Pred: nonvul | Output: const char *app_extensions,
                             const char *runtime_ext...
→ Sample 184/236 | True: nonvul | Pred: nonvul | Output: Code: DynamicBroadcastInDimOpLowering::DynamicBroadcastInDimOpLowering(
    MLIR...
→ Sample 185/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 186/236 | True: nonvul | Pred: nonvul | Output: Code: LiteralString *hermes::evalToString(IRBuilder &builder, Literal *operand) ...
[NONVUL] Sample 200/236 [len=148]
→ Sample 187/236 | True: nonvul | Pred: nonvul | Output: Code: LiteralNumber *hermes::evalToInt32(IRBuilder &builder, Literal *operand) {...
→ Sample 188/236 | True: nonvul | Pred: nonvul | Output: Code: LiteralNumber *hermes::evalToNumber(IRBuilder &builder, Literal *operand) ...
→ Sample 189/236 | True: nonvul | Pred: nonvul | Output: Code: LiteralBool *hermes::evalToBoolean(IRBuilder &builder, Value *operand) {
 ...
→ Sample 190/236 | True: nonvul | Pred: nonvul | Output: Code: Status FunctionLibraryDefinition::RemoveGradient(const string& func) {
  c...
→ Sample 191/236 | True: nonvul | Pred: nonvul | Output: Code: Status FunctionCallFrame::GetArg(int index, const Tensor** val) {
  if (in...
→ Sample 192/236 | True: nonvul | Pred: nonvul | Output: Code: std::vector<string> FunctionLibraryDefinition::ListFunctionNames() const {...
→ Sample 193/236 | True: nonvul | Pred: nonvul | Output: the input type.
        if (item->dtypes[j] != dtypes[j]) {
          return err...
→ Sample 194/236 | True: nonvul | Pred: nonvul | Output: Code: Status FunctionLibraryDefinition::GetAttr(const Node& node, const string& ...
→ Sample 195/236 | True: nonvul | Pred: nonvul | Output: Code: Status FunctionLibraryDefinition::GetAttr(const NodeDef& ndef,
           ...
→ Sample 196/236 | True: nonvul | Pred: nonvul | Output: Code: string FunctionLibraryRuntime::ExecutorType(const InstantiateOptions& opti...
[NONVUL] Sample 210/236 [len=74]
→ Sample 197/236 | True: nonvul | Pred: nonvul | Output: Code: string FunctionLibraryDefinition::UniqueFunctionName(StringPiece prefix) c...
→ Sample 198/236 | True: nonvul | Pred: nonvul | Output: Code: string FunctionLibraryRuntime::Options::DebugString() const {
  return abs...
→ Sample 199/236 | True: nonvul | Pred: nonvul | Output: Code: FunctionDef FunctionDefHelper::Define(gtl::ArraySlice<string> arg_def,
   ...
→ Sample 200/236 | True: nonvul | Pred: nonvul | Output: Code: FunctionDef FunctionDefHelper::Create(
    const string& function_name, gt...
[NONVUL] Progress: 200/236 completed, 200 with L0 data (100.0% success)
→ Sample 201/236 | True: nonvul | Pred: nonvul | Output: Code: string Print(const OpDef::ArgDef& arg) {
  string out;
  strings::StrAppen...
→ Sample 202/236 | True: nonvul | Pred: nonvul | Output: Code: FunctionLibraryDefinition FunctionLibraryDefinition::ReachableDefinitions(...
→ Sample 203/236 | True: nonvul | Pred: nonvul | Output: Code: bool RegisterOp(const string& op, Creator func) {
  CHECK(GetOpGradFactory...
→ Sample 204/236 | True: nonvul | Pred: nonvul | Output: Code: Status FunctionLibraryDefinition::ReplaceGradient(const GradientDef& grad)...
→ Sample 205/236 | True: nonvul | Pred: nonvul | Output: Code: Status FunctionLibraryDefinition::RemoveFunction(const string& func) {
  m...
→ Sample 206/236 | True: nonvul | Pred: nonvul | Output: code safe or vulnerable?
Answer: It is safe.
[NONVUL] Sample 220/236 [len=81]
→ Sample 207/236 | True: nonvul | Pred: nonvul | Output: Failed to create work directory");

	if (tmate_settings->bind_addr) {
		if (bind...
→ Sample 208/236 | True: nonvul | Pred: nonvul | Output: Code: void set_session_token(struct tmate_session *session, const char *token)
{...
→ Sample 209/236 | True: nonvul | Pred: vul | Output: NAME;

	if ((gai_result = getaddrinfo(hostname, NULL, &hints, &info)) != 0) {
		...
→ Sample 210/236 | True: nonvul | Pred: vul | Output: Code: void pjmedia_rtcp_xr_tx_rtp( pjmedia_rtcp_xr_session *session, 
			     un...
→ Sample 211/236 | True: nonvul | Pred: vul | Output: Code: void pjmedia_rtcp_xr_fini(pjmedia_rtcp_xr_session *session)
{
    PJ_UNUSE...
→ Sample 212/236 | True: nonvul | Pred: nonvul | Output: Code: void ExtractValue(DimensionHandle d, int64_t* result) {
    if (!Inference...
→ Sample 213/236 | True: nonvul | Pred: nonvul | Output: Code: bool operator==(const ShapeId& other) const {
      return node == other.n...
→ Sample 214/236 | True: nonvul | Pred: nonvul | Output: Yes, it is safe.
→ Sample 215/236 | True: nonvul | Pred: nonvul | Output: ::DimensionHandle dim =
            InferenceContext::DimKnownRank(actual_shape,...
→ Sample 216/236 | True: nonvul | Pred: vul | Output: x_root->rank + 1;
  }
  return Status::OK();
}

Question: Is this code safe or v...
[NONVUL] Sample 230/236 [len=459]
→ Sample 217/236 | True: nonvul | Pred: nonvul | Output: Code: bool EquivalentShapesAndTypes(const std::vector<ShapeAndType>& st1,
      ...
→ Sample 218/236 | True: nonvul | Pred: nonvul | Output: as_shape,
                                     const DataType& dtype) {
  Tensor...
→ Sample 219/236 | True: nonvul | Pred: nonvul | Output: continue;
    }
    std::vector<OpInfo::TensorProperties> inputs =
        FindI...
→ Sample 220/236 | True: nonvul | Pred: nonvul | Output: Code: bool IsIntegerVector(const Tensor& tensor) {
    if (tensor.dims() == 1 &&...
→ Sample 221/236 | True: nonvul | Pred: nonvul | Output: Code: bool HasAnyUnknownDimensions(const TensorShapeProto& proto) {
  if (proto....
→ Sample 222/236 | True: nonvul | Pred: nonvul | Output: : It is safe.
[NONVUL] Sample 236/236 [len=265]
→ Sample 223/236 | True: nonvul | Pred: nonvul | Output: Code: static MagickBooleanType IsPCL(const unsigned char *magick,const size_t le...
→ Sample 224/236 | True: nonvul | Pred: nonvul | Output: ->name_entry_size;
  }

offset = GET2(slot, 0) << 1;
GET_LOCAL_BASE(TMP2, 0, OVE...
→ Sample 225/236 | True: nonvul | Pred: nonvul | Output: Code: static void add_stub(compiler_common *common, struct sljit_jump *start)
{
...
→ Sample 226/236 | True: nonvul | Pred: nonvul | Output: (compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_scrip...
→ Sample 227/236 | True: nonvul | Pred: nonvul | Output: add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));
  }
JUMPHERE(jump);...
→ Sample 228/236 | True: nonvul | Pred: nonvul | Output: Code: static BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, ...
→ Sample 229/236 | True: nonvul | Pred: vul | Output: Code: static void jumpto_if_not_utf_char_start(struct sljit_compiler *compiler, ...
→ Sample 230/236 | True: nonvul | Pred: nonvul | Output: It is safe.
→ Sample 231/236 | True: nonvul | Pred: nonvul | Output: Code: Status check_index_ordering(const Tensor& indices) {
    if (indices.NumEl...
→ Sample 232/236 | True: nonvul | Pred: nonvul | Output: Code: void Compute(OpKernelContext* ctx) override {
    StagingMap<Ordered>* map...
→ Sample 233/236 | True: nonvul | Pred: nonvul | Output: Code: std::size_t operator()(const Tensor& key) const {
    return std::hash<int...
→ Sample 234/236 | True: nonvul | Pred: nonvul | Output: Code: TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (tuple[index].has_value()) {
   ...
→ Sample 235/236 | True: nonvul | Pred: nonvul | Output: {
    StagingMap<Ordered>* map = nullptr;
    OP_REQUIRES_OK(ctx, GetStagingMap(...
→ Sample 236/236 | True: nonvul | Pred: nonvul | Output: It is safe.
[INFO] Calculating classification metrics...

=== Classification Summary ===
Total samples: 472
Classified (non-unknown): 472
Unknown predictions: 0 (0.0%)
  - Unknown among VUL: 0
  - Unknown among NONVUL: 0

Confusion Matrix:
True Positive (TP): 83
False Positive (FP): 14
True Negative (TN): 222
False Negative (FN): 153

Metrics (on non-unknown):
Accuracy: 0.6462
Precision: 0.8557
Recall: 0.3517
F1 score: 0.4985
Overall accuracy (incl. unknown): 0.6462
[SAVED] Plot saved: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out/plots/20260222_174032/l0_comparison.png
[SAVED] All samples L0 trends plot saved: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out/plots/20260222_174032/l0_all_samples_trends.png

[DONE] Results saved: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out/log/20260222_174032/out.json
[INFO] Saving all model prediction outputs...
[SAVED] All predictions saved to: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out/log/20260222_174032/all_predictions.json
[SAVED] Human-readable predictions saved to: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out/log/20260222_174032/all_predictions.txt

[COMPLETE] Generated 472 prediction outputs
 [OK] Step 1 finished at Sun Feb 22 08:28:16 PM CET 2026

Most recent prime output JSON: /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/out/log/20260222_174032/out.json

──────────────────────────────────────────────────────────
 Step 2: Attention Head Analysis
 Script : attention_analysis.py
 Started: Sun Feb 22 08:28:16 PM CET 2026
──────────────────────────────────────────────────────────
 [OK] Step 2 finished at Sun Feb 22 08:30:31 PM CET 2026

──────────────────────────────────────────────────────────
 Step 3: Causal Patching
 Script : causal_patching.py
 Started: Sun Feb 22 08:30:31 PM CET 2026
──────────────────────────────────────────────────────────
 [OK] Step 3 finished at Sun Feb 22 10:19:16 PM CET 2026

──────────────────────────────────────────────────────────
 Step 4: Causal Validation (Ablation)
 Script : causal_validation.py
 Started: Sun Feb 22 10:19:16 PM CET 2026
──────────────────────────────────────────────────────────

[INIT] Loading neuron IDs from /lunarc/nobackup/projects/lu2024-17-13/chun7871/LLMvul/data/neuron_analysis.json...
  Layer 6: Loaded 20 neuron IDs (e.g., [5058, 8603, 7462]...)
  Layer 7: Loaded 20 neuron IDs (e.g., [7662, 8793, 4126]...)
  Layer 10: Loaded 20 neuron IDs (e.g., [1891, 1928, 993]...)
  Layer 11: Loaded 20 neuron IDs (e.g., [8376, 450, 1723]...)
  Loaded neuron IDs for 4 layers
